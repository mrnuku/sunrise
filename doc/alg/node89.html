<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!--Converted with LaTeX2HTML 98.1p1 release (March 2nd, 1998)
originally by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>0.4.4 Dijkstra's Algorithm - Shortest Path</TITLE>
<META NAME="description" CONTENT="0.4.4 Dijkstra's Algorithm - Shortest Path">
<META NAME="keywords" CONTENT="alg">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<LINK REL="STYLESHEET" HREF="alg.css">
<LINK REL="next" HREF="node92.html">
<LINK REL="previous" HREF="node88.html">
<LINK REL="up" HREF="node80.html">
<LINK REL="next" HREF="node90.html">
</HEAD>
<BODY bgcolor=#cccc99 text=#555555 link=#993300 alink=#006666 vlink=#993300>
<!--Navigation Panel-->
<A NAME="tex2html1471"
 HREF="node90.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html1467"
 HREF="node80.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html1461"
 HREF="node88.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A> 
<A NAME="tex2html1469"
 HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents_motif.gif"></A> 
<A NAME="tex2html1470"
 HREF="node194.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> <A HREF="/cgi-bin/glimpse?title=search+the+algorithm+archive&dir=%2fusr%2flocal%2Finfo%2Fhttp%2Fhtdocs%2Fdata%2Fscott%2Fsearch%2Findex%2Falg">Search</A>
<BR>
<B> Next:</B> <A NAME="tex2html1472"
 HREF="node90.html">0.4.4.1 Analysis</A>
<B> Up:</B> <A NAME="tex2html1468"
 HREF="node80.html">0.4 Graph Algorithms</A>
<B> Previous:</B> <A NAME="tex2html1462"
 HREF="node88.html">0.4.3 Floyd's Algorithm -</A>
<BR>
<BR><TABLE WIDTH=640 BGCOLOR=#000000 ALIGN=CENTER CELLPADDING=5><TD><TABLE WIDTH=640 BGCOLOR=#ffffff CELLSPACING=0 ALIGN=CENTER CELLPADDING=5 CELLPADDING=5><TD>
<!--End of Navigation Panel-->

<H2><A NAME="SECTION00054000000000000000">&#160;</A>
<A NAME="2239">&#160;</A>
<A NAME="2240">&#160;</A>
<BR>
0.4.4 Dijkstra's Algorithm - Shortest Path
</H2>

<P>
While Floyd's algorithm determines the lowest-cost path
between all vertices in a graph, Dijkstra's was designed to
find the lowest cost path between a single starting vertex
and all of the other vertices in a graph.  Dijkstra's can, clearly,
be used to obtain the same information as Floyd's algorithm
if it is called repeatedly for every vertex in a graph.
<A NAME="2241">&#160;</A>

<P>
Dikjstra's algorithm is a <B>greedy algorithm</B> which
<A NAME="2243">&#160;</A>
<A NAME="2244">&#160;</A>
means, if given a choice, it operates by choosing the biggest
or most valuable alternative.

<P>
The first step of this algorithm is to "label" the starting vertex
with an ordered pair, (-,0), and initialize a distance counter to one.
Next, look at all edges between labeled vertices and unlabeled
vertices.  If the cost of a particular edge added to the second item
in the ordered pair of the initial vertex is equal to the distance
counter, label the terminal vertex of this edge (<TT>name_of_starting_vertex</TT>, <TT>distance_counter</TT>) and continue
this process, incrementing the distance counter by one at each
iteration and continuing until all vertices in the graph are labeled.
The second member of the ordered pair at each vertex is the lowest
cost walk from it to the starting vertex.  The first member of the
ordered pair of the ordered pair is the node immediately preceding the
current node on the shortest path from source to destination.

<P>
The algorithm actually coded is implemented in a slightly different
manner.  Because it is inefficient to store the distance counter and
look at every edge at every increment, I choose to begin at the
starting vertex and traverse to all nodes reachable from it.  Each
node is labelled with a distance from the start and a previous
vertex.  Each node is also enqueued for later processing.

<P>
Once all nodes adjacent to the starting vertex are processed, labelled
and enqueued, the algorithm dequeues the first node.  All nodes
adjacent to this vertex that have not been visited are labelled and
enqueued.  Additionally, any node that has been visited but can be
reached more cheaply is re-labelled and enqueued.

<P>
This process continues until the queue is empty.  The shortest path to
a given vertex <I>n</I> is labelled on that vertex.  The path can be
determined by examining the prior steps recursively back to the
starting node.

<P>
<BR><HR>
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS">&#160;</A>
<UL>
<LI><A NAME="tex2html1473"
 HREF="node90.html">0.4.4.1 Analysis</A>
<LI><A NAME="tex2html1474"
 HREF="node91.html">0.4.4.2 Source Code</A>
</UL>
<!--End of Table of Child-Links-->
</TD></TABLE></TD></TABLE>

<!--End of Navigation Panel-->
<ADDRESS>
<I>Scott Gasch</I>
<BR><I>1999-07-09</I>
</ADDRESS>
</BODY>
</HTML>
