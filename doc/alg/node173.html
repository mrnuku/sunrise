<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!--Converted with LaTeX2HTML 98.1p1 release (March 2nd, 1998)
originally by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>0.10.4 Adaptive Huffman Compression</TITLE>
<META NAME="description" CONTENT="0.10.4 Adaptive Huffman Compression">
<META NAME="keywords" CONTENT="alg">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<LINK REL="STYLESHEET" HREF="alg.css">
<LINK REL="next" HREF="node175.html">
<LINK REL="previous" HREF="node170.html">
<LINK REL="up" HREF="node163.html">
<LINK REL="next" HREF="node174.html">
</HEAD>
<BODY bgcolor=#cccc99 text=#555555 link=#993300 alink=#006666 vlink=#993300>
<!--Navigation Panel-->
<A NAME="tex2html2545"
 HREF="node174.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html2541"
 HREF="node163.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html2535"
 HREF="node172.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A> 
<A NAME="tex2html2543"
 HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents_motif.gif"></A> 
<A NAME="tex2html2544"
 HREF="node194.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> <A HREF="/cgi-bin/glimpse?title=search+the+algorithm+archive&dir=%2fusr%2flocal%2Finfo%2Fhttp%2Fhtdocs%2Fdata%2Fscott%2Fsearch%2Findex%2Falg">Search</A>
<BR>
<B> Next:</B> <A NAME="tex2html2546"
 HREF="node174.html">0.10.4.1 References</A>
<B> Up:</B> <A NAME="tex2html2542"
 HREF="node163.html">0.10 Data Compression Algorithms</A>
<B> Previous:</B> <A NAME="tex2html2536"
 HREF="node172.html">0.10.3.2 References</A>
<BR>
<BR><TABLE WIDTH=640 BGCOLOR=#000000 ALIGN=CENTER CELLPADDING=5><TD><TABLE WIDTH=640 BGCOLOR=#ffffff CELLSPACING=0 ALIGN=CENTER CELLPADDING=5 CELLPADDING=5><TD>
<!--End of Navigation Panel-->

<H2><A NAME="SECTION000114000000000000000">
0.10.4 Adaptive Huffman Compression</A>
</H2>

<P>
If there are <I>x</I> levels in a Huffman tree, read the node values on
each level <I>l</I><SUB><I>x</I></SUB> from left to right.  When you have exhausted level
<I>l</I><SUB><I>x</I></SUB> move up a level to <I>l</I><SUB><I>x</I>-1</SUB> and repeat the process.  Continue
until you have moved up to the root node (and, thus, have read the
value of every node in the tree).

<P>
You should notice an interesting pattern - the values always remain
the same or increase.  This is called the <B>sibling property</B> of
Huffman trees.  It tell us that given a node <I>n</I>, its sibling <I>s</I>(<I>n</I>)is the node on the same level as <I>n</I> to the right.  If <I>n</I> is the
rightmost node on its level, <I>s</I>(<I>n</I>) is the leftmost node on previous
level.  If <I>v</I><SUB><I>n</I></SUB> is the value of node <I>n</I>, we know that <I>v</I><SUB><I>s</I>(<I>n</I>)</SUB>,
the value of the sibling, will be greater than or equal to <I>v</I><SUB><I>n</I></SUB>.
If you understand this property understanding the rest of this
algorithm is a breeze.

<P>
One of the drawbacks of static Huffman compression algorithms is the
need to transmit the character frequency tally with the compressed
text.  While an intelligently encoded table only adds about 250 bytes
(on average) to a compressed image, it would be nice to get rid of it
all together.  This seems to be impossible because without the table's
data the decompression routine would not know the structure of the
Huffman tree used to encode the compressed data and therefore would
not be able to ascertain the proper codeword to character mappings.

<P>
However, adaptive Huffman compression algorithms overcome the need to
store the character counts by beginning with a mostly empty tree.
They then build up and fill in the tree as they go.  The Huffman trees
generated by adaptive algorithms are dynamic meaning they change in
structure as the statistical tendancies of the text change.  The
compression function adds each new character encountered to the tree.
The algorithm does not, however, compress the character the first time
it is seen.  Instead the character is passed on to the compressed text
as is (in fact, a special flag character is pre-pended to it, as we
will discuss in the next paragraph).  When the compression system sees
a character already present in the tree, it increments that
character's count by one, adjusts the tree accordingly, and uses the
compression code in the output stream.

<P>
The complimentary decompression routine operates in much the same
manner - when a new character is encountered it is added to the
dynamic Huffman tree but otherwise left alone.  When a code is found
it is decoded and the weight of the cooresponding character is
increased.  This increase may cause the tree to be reorganized.

<P>
The way that plain (non-compressed) characters and (compressed)
codewords are distinguished in the compressed stream is by use of a
flag or <B>escape</B> character.  This symbol, when encountered,
signifies that the next byte is a literal character.  All other data
is assumed to be codes.  The escape symbol is one of the only items
present in the initial Huffman tree.  When the decompression
subroutine runs across the code for an escape symbol it immediately
reads a byte from the input, adds it to the tree, and sends it to
output.  Note that I am not talking about the escape character here
(ASCII 27) but rather a made-up symbol that has a node on the Huffman
tree.  This symbol, of course, produces no output in the uncompressed
stream - its sole function is to convey a message from the
compression routine to the decompression routine about the character
following it in the stream.

<P>
The complicated part of this algorithm, as you might expect, is the
tree manipulation.  It is unreasonable to reconstruct the entire
Huffman tree every time a symbol is added to it.  But recall from the
opening paragraph of this section that all Huffman trees must obey the 
sibling property.

<P>
Imagine the steps of incrementing a Huffman node's weight: first,
since all nodes are stored at the leaves of the tree, we will add one
to the count of a leaf.  We must now make sure the tree follows the
sibling property.  If our incremented leaf, <I>i</I>, has a larger value
then its sibling then the sibling rule is broken.

<P>
When the sibling property has been broken matters can be fixed by
swaping the offending incremented node <I>i</I> with its sibling.  This
will not always work, though.  Imagine that there is a node <I>n</I> with
value 5.  Its immediate sibling is node <I>o</I> with value 5 also.
The immediate sibling of <I>p</I> is 5 also.  (That is, there are three
leaf nodes in a row, all value 5).  Now we increment node <I>n</I> to
6.  The sibling property is broken because now <I>n</I> has a larger
value than its right sibling, <I>o</I> (which is still 5).  Swapping the
two would be a problem because <I>n</I> is also larger than <I>o</I>'s sibling,
<I>p</I>.

<P>
The proper way to restore the sibling property when it has been
violated by an incrementation is to loop over the siblings starting
with the immediate sibling of the incremented node.  Continue to loop
while the value of the nodes encountered stays the same.  Break out of 
the loop when the value changes.  Swap the incremented node with the
last node in the run of same values:

<P>
<PRE>
...
node[i].value++;
if (node[i].value &gt; node[i+1].value)
{
  val = node[i+1].value;
  j = i+1;
  while (node[j].value == val)
  {
    j++;
  }
  swap (node[i], node[j-1]);
}
...
</PRE>
<P>
The above code assumes, of course, that we can traverse along siblings 
by simply moving to adjacent positions in a node array.  In order to
implement an adaptive Huffman algorithm it should be easy to find the
sibling of a given node many times in a row.

<P>
<BR><HR>
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS">&#160;</A>
<UL>
<LI><A NAME="tex2html2547"
 HREF="node174.html">0.10.4.1 References</A>
</UL>
<!--End of Table of Child-Links-->
</TD></TABLE></TD></TABLE>

<!--End of Navigation Panel-->
<ADDRESS>
<I>Scott Gasch</I>
<BR><I>1999-07-09</I>
</ADDRESS>
</BODY>
</HTML>
