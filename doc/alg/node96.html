<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!--Converted with LaTeX2HTML 98.1p1 release (March 2nd, 1998)
originally by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>0.4.5.2.1 Source Code</TITLE>
<META NAME="description" CONTENT="0.4.5.2.1 Source Code">
<META NAME="keywords" CONTENT="alg">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<LINK REL="STYLESHEET" HREF="alg.css">
<LINK REL="previous" HREF="node95.html">
<LINK REL="up" HREF="node95.html">
<LINK REL="next" HREF="node97.html">
</HEAD>
<BODY bgcolor=#cccc99 text=#555555 link=#993300 alink=#006666 vlink=#993300>
<!--Navigation Panel-->
<A NAME="tex2html1555"
 HREF="node97.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html1551"
 HREF="node95.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html1547"
 HREF="node95.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A> 
<A NAME="tex2html1553"
 HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents_motif.gif"></A> 
<A NAME="tex2html1554"
 HREF="node194.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> <A HREF="/cgi-bin/glimpse?title=search+the+algorithm+archive&dir=%2fusr%2flocal%2Finfo%2Fhttp%2Fhtdocs%2Fdata%2Fscott%2Fsearch%2Findex%2Falg">Search</A>
<BR>
<B> Next:</B> <A NAME="tex2html1556"
 HREF="node97.html">0.4.6 Transitive Closure</A>
<B> Up:</B> <A NAME="tex2html1552"
 HREF="node95.html">0.4.5.2 Kruskal's Algorithm</A>
<B> Previous:</B> <A NAME="tex2html1548"
 HREF="node95.html">0.4.5.2 Kruskal's Algorithm</A>
<BR>
<BR><TABLE WIDTH=640 BGCOLOR=#000000 ALIGN=CENTER CELLPADDING=5><TD><TABLE WIDTH=640 BGCOLOR=#ffffff CELLSPACING=0 ALIGN=CENTER CELLPADDING=5 CELLPADDING=5><TD>
<!--End of Navigation Panel-->

<H4><A NAME="SECTION00055210000000000000">
0.4.5.2.1 Source Code</A>
</H4>

<P>
Here is some untested code that implements Kruskal's algorithm in C++.
It relies on a heap class, a graph class, and a general tree class
with equivalence class operation methods.  Although none of these
classes are included here, this should be sufficient to give you an
idea of how to implement Kruskal's algorithm:

<P>
<HR><PRE>
void kruskal(graph \&g) {

  // our general equivalence class tree will have as many nodes as are
  // in the input graph G.  We will be linking these nodes up in the
  // body of the algorithm.
  gentree a(g.num_nodes());

  // we will also need an edge heap array in order to process the
  // edges in G one at a time in the order small-&gt;large
  edge e(G.num_edges());

  // the edge we are considering... also a loop storage variable
  edge w;
  
  // local counter
  int edge_count = 0;

  // loop control
  int i;

  // this is the number of spanning trees we are considering.  This
  // will start at the number of vertices in G but, as vertices are
  // joined up by lowest-weight edges, this will reduce.  Eventually
  // it will hit one at which point we know we should stop the algorithm.
  int numMST;

  // these are the endpoints of the edge we are considering
  vertex v, u;

  // save all the edges in G for later processing.
  for (i = 0; i &lt; g.num_nodes; i++) {
    for (w = g.first_edge(i); g.is_edge(w); w = g.next_edge(w))
      e[edge_count++] = w;

    
  // min-heapify the edges
  minheap h(e, edge_count);

  // initially there are the same numer of equivalence classes as
  // the number of vertices in G; each vertex is its own class.
  numMST = G.num_nodes();

  // while we have not yet arrived at one equivalence class (spanning
  // tree)...
  for (i = 0; numMST &gt; 1; i++) {

     // consider the next smallest edge
     w = h.remove_min();

     // look at w's endpoints
     v = g.vertex_one(w); u = g.vertex_two(w);

     // if these two vertices are not in the same equivalence class
     // (i.e. they are in different tree sections) join their
     // respective equivalence classes into one.
     if (a.differ(v.identifier(), u.identifier())) {
       a.union(v, u);
       add_edge_to_MST(w);

       // one less
       numMST--;
     }
  }
}
</PRE> 
<HR><P>
</TD></TABLE></TD></TABLE>

<!--End of Navigation Panel-->
<ADDRESS>
<I>Scott Gasch</I>
<BR><I>1999-07-09</I>
</ADDRESS>
</BODY>
</HTML>
