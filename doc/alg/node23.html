<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!--Converted with LaTeX2HTML 98.1p1 release (March 2nd, 1998)
originally by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>0.2.5 B+-Trees</TITLE>
<META NAME="description" CONTENT="0.2.5 B+-Trees">
<META NAME="keywords" CONTENT="alg">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<LINK REL="STYLESHEET" HREF="alg.css">
<LINK REL="next" HREF="node25.html">
<LINK REL="previous" HREF="node18.html">
<LINK REL="up" HREF="node7.html">
<LINK REL="next" HREF="node24.html">
</HEAD>
<BODY bgcolor=#cccc99 text=#555555 link=#993300 alink=#006666 vlink=#993300>
<!--Navigation Panel-->
<A NAME="tex2html615"
 HREF="node24.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html611"
 HREF="node7.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html605"
 HREF="node22.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A> 
<A NAME="tex2html613"
 HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents_motif.gif"></A> 
<A NAME="tex2html614"
 HREF="node194.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> <A HREF="/cgi-bin/glimpse?title=search+the+algorithm+archive&dir=%2fusr%2flocal%2Finfo%2Fhttp%2Fhtdocs%2Fdata%2Fscott%2Fsearch%2Findex%2Falg">Search</A>
<BR>
<B> Next:</B> <A NAME="tex2html616"
 HREF="node24.html">0.2.5.1 Source Code</A>
<B> Up:</B> <A NAME="tex2html612"
 HREF="node7.html">0.2 Data Searching and</A>
<B> Previous:</B> <A NAME="tex2html606"
 HREF="node22.html">0.2.4.4 References</A>
<BR>
<BR><TABLE WIDTH=640 BGCOLOR=#000000 ALIGN=CENTER CELLPADDING=5><TD><TABLE WIDTH=640 BGCOLOR=#ffffff CELLSPACING=0 ALIGN=CENTER CELLPADDING=5 CELLPADDING=5><TD>
<!--End of Navigation Panel-->

<H2><A NAME="SECTION00035000000000000000">&#160;</A>
<A NAME="272">&#160;</A>
<A NAME="273">&#160;</A>
<BR>
0.2.5 B+-Trees
</H2>

<P>
A B+-tree is a data structure to store vast amounts of information.
Typically B+-trees are used to store amounts of data that will not fit
in main system memory.  To do this, secondary storage (usually disk)
is used to store the leaf nodes of the tree.  Only the internal nodes
of the tree are stored in computer memory.  In a B+-tree the leaf
nodes are the only ones that actually store data items.  All other
nodes are called <B>index nodes</B> or <B>i-nodes</B>
<A NAME="276">&#160;</A>
<A NAME="277">&#160;</A>
<A NAME="278">&#160;</A>
and simply store ``guide'' values which allow us to traverse the tree
structure from the root down and arrive at the leaf node containing
the data item we seek.  Because disk I/O is very slow in comparison to
memory access these leaf nodes store more than one data item each.  In
fact, the data structure will perform best when the size of the leaf
nodes closely approximates the size of a disk sector under most
operating systems.  Thus, when we search a B+-tree (by traversing from
the root node down to the proper data node) we still must read that
data node from the disk and search its contents.  Another way to
improve the speed of a query operation is to keep a memory cache of
recently read leaf nodes.

<P>
The ancestor of the B+-tree is a structure known as a B-tree in which
data items can be stored in any node on the tree.  A more complicated
and slightly more robust varient of the B-tree is called a B*-tree.
<A NAME="279">&#160;</A>
<A NAME="280">&#160;</A>

<P>
While conceptually simple in nature, the challenging aspect of B+-trees
is effecting their growth and collapse.  When data nodes in the tree
become too full they split into two nodes.  This process demands that
a new guide value be added to the parent index node so that future
queries can arbitrate between the two new nodes.  However, adding this
new guide value to the parent may cause it, in turn, to split.  In
fact, all the nodes on a path from a leaf to the root may split when
you add a new value to a leaf node.  If the root node splits, a new
leaf node is created and your tree grows by one level.

<P>
Conversely, the deletion of data items in a leaf node may cause that
node to become too empty.  When a data node becomes too empty,
neighboring nodes are examined and merged into underfull node.  This
causes the deletion of a guide value in the parent index node which,
in turn, may cause it to become too empty.  Much like the ripple
caused by an insertion operation, a key deletion may cause a
merge-delete wave to run from a leaf node all the way up to the
root.  When the children of the root are merged into one and the root
node's only value is deleted the root index node is deallocated, its
child node becomes the new root, and the tree shrinks by one level.

<P>
As you can see, insertion and deletion processes are recursive in
nature and can cascade up or down the B+-tree affecting its shape
dramatically.

<P>
<BR><HR>
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS">&#160;</A>
<UL>
<LI><A NAME="tex2html617"
 HREF="node24.html">0.2.5.1 Source Code</A>
</UL>
<!--End of Table of Child-Links-->
</TD></TABLE></TD></TABLE>

<!--End of Navigation Panel-->
<ADDRESS>
<I>Scott Gasch</I>
<BR><I>1999-07-09</I>
</ADDRESS>
</BODY>
</HTML>
