<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!--Converted with LaTeX2HTML 98.1p1 release (March 2nd, 1998)
originally by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>0.3.9 Bucket and Radix Sorting</TITLE>
<META NAME="description" CONTENT="0.3.9 Bucket and Radix Sorting">
<META NAME="keywords" CONTENT="alg">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<LINK REL="STYLESHEET" HREF="alg.css">
<LINK REL="next" HREF="node76.html">
<LINK REL="previous" HREF="node73.html">
<LINK REL="up" HREF="node42.html">
<LINK REL="next" HREF="node75.html">
</HEAD>
<BODY bgcolor=#cccc99 text=#555555 link=#993300 alink=#006666 vlink=#993300>
<!--Navigation Panel-->
<A NAME="tex2html1274"
 HREF="node75.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html1270"
 HREF="node42.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html1264"
 HREF="node73.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A> 
<A NAME="tex2html1272"
 HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents_motif.gif"></A> 
<A NAME="tex2html1273"
 HREF="node194.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> <A HREF="/cgi-bin/glimpse?title=search+the+algorithm+archive&dir=%2fusr%2flocal%2Finfo%2Fhttp%2Fhtdocs%2Fdata%2Fscott%2Fsearch%2Findex%2Falg">Search</A>
<BR>
<B> Next:</B> <A NAME="tex2html1275"
 HREF="node75.html">0.3.9.1 Analysis</A>
<B> Up:</B> <A NAME="tex2html1271"
 HREF="node42.html">0.3 Sorting Algorithms</A>
<B> Previous:</B> <A NAME="tex2html1265"
 HREF="node73.html">0.3.8 Bubble Sort</A>
<BR>
<BR><TABLE WIDTH=640 BGCOLOR=#000000 ALIGN=CENTER CELLPADDING=5><TD><TABLE WIDTH=640 BGCOLOR=#ffffff CELLSPACING=0 ALIGN=CENTER CELLPADDING=5 CELLPADDING=5><TD>
<!--End of Navigation Panel-->

<H2><A NAME="SECTION00049000000000000000">&#160;</A>
<A NAME="1406">&#160;</A>
<BR>
0.3.9 Bucket and Radix Sorting
</H2>
<A NAME="1407">&#160;</A>

<P>
The bucket sort is a non-comparison-based sorting algorithm in which
we allocate one storage location for each item to be sorted and
proceed to process the data set to be sorted assigning each item into
its corresponding bucket.  In order to bucket sort <I>n</I> unique items in
the range of 1 through <I>m</I>, allocate <I>m</I> buckets and then iterate
over the <I>n</I> items assigning each one to the proper bucket.  Finally
loop through the buckets and collect the items putting them into final
order.

<P>
The bucket sort is a good choice when items to be sorted are from a
small data range that is known in advance.

<P>
One problem with the bucket sort is that, if the range of items to be
sorted is very large, an unreasonable amount of memory is required to
allocate enough buckets.  A method very similar to bucket sorting
called radix sorting elegantly handles this problem.  In a radix sort
the data to be sorted is broken down into several buckets, like in the
bucket sort.  The difference is that many items are assigned to each
bucket in the radix sort because to assign an item to a bucket the
radix sort only considers a subset of the item key.  Often the bucket
to which an item is assigned with the radix sort is based on a certain
digit or subset of the item's key value.  The radix sort recursively
processes the contents of each bucket by allocating sub-buckets and
assigning items into sub-buckets by considering a different subrange
of the items' keys.  This process continues until there is only one
item per bucket at which point items are recollected in order.

<P>
For example, sorting social security numbers with a radix method one
might divide the entire data space into ten sets.  The members of set
number one would be the social security numbers beginning with the
digit 1, etc.  The numbers in set one would be subdivided based on
the second digit in each social security number, and so on until the
entire set was sorted.

<P>
<BR><HR>
<!--Table of Child-Links-->
<A NAME="CHILD_LINKS">&#160;</A>
<UL>
<LI><A NAME="tex2html1276"
 HREF="node75.html">0.3.9.1 Analysis</A>
</UL>
<!--End of Table of Child-Links-->
</TD></TABLE></TD></TABLE>

<!--End of Navigation Panel-->
<ADDRESS>
<I>Scott Gasch</I>
<BR><I>1999-07-09</I>
</ADDRESS>
</BODY>
</HTML>
