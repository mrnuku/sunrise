<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!--Converted with LaTeX2HTML 98.1p1 release (March 2nd, 1998)
originally by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>0.2.2.2 Source Code</TITLE>
<META NAME="description" CONTENT="0.2.2.2 Source Code">
<META NAME="keywords" CONTENT="alg">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<LINK REL="STYLESHEET" HREF="alg.css">
<LINK REL="next" HREF="node13.html">
<LINK REL="previous" HREF="node11.html">
<LINK REL="up" HREF="node10.html">
<LINK REL="next" HREF="node13.html">
</HEAD>
<BODY bgcolor=#cccc99 text=#555555 link=#993300 alink=#006666 vlink=#993300>
<!--Navigation Panel-->
<A NAME="tex2html482"
 HREF="node13.html">
<IMG WIDTH="37" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next" SRC="next_motif.gif"></A> 
<A NAME="tex2html478"
 HREF="node10.html">
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up" SRC="up_motif.gif"></A> 
<A NAME="tex2html472"
 HREF="node11.html">
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous" SRC="previous_motif.gif"></A> 
<A NAME="tex2html480"
 HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="contents" SRC="contents_motif.gif"></A> 
<A NAME="tex2html481"
 HREF="node194.html">
<IMG WIDTH="43" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="index" SRC="index_motif.gif"></A> <A HREF="/cgi-bin/glimpse?title=search+the+algorithm+archive&dir=%2fusr%2flocal%2Finfo%2Fhttp%2Fhtdocs%2Fdata%2Fscott%2Fsearch%2Findex%2Falg">Search</A>
<BR>
<B> Next:</B> <A NAME="tex2html483"
 HREF="node13.html">0.2.2.3 References</A>
<B> Up:</B> <A NAME="tex2html479"
 HREF="node10.html">0.2.2 Binary Search</A>
<B> Previous:</B> <A NAME="tex2html473"
 HREF="node11.html">0.2.2.1 Analysis</A>
<BR>
<BR><TABLE WIDTH=640 BGCOLOR=#000000 ALIGN=CENTER CELLPADDING=5><TD><TABLE WIDTH=640 BGCOLOR=#ffffff CELLSPACING=0 ALIGN=CENTER CELLPADDING=5 CELLPADDING=5><TD>
<!--End of Navigation Panel-->

<H3><A NAME="SECTION00032200000000000000">
0.2.2.2 Source Code</A>
</H3>

<P>
Below is an iterative implementation of the binary search in C.  The
binary search algorithm can be implemented as a recursive algorithm
also.

<P>
<HR>
<DIV><TT>
<BR><HR>
<BR><PRE>//+----------------------------------------------------------------------------
 //
 // File:     binsearch.c
 //
 // Module:   Binary Search Example
 //
 // Synopsis: Sample binary search code.
 //
 // Author:	 sgasch
 //
 // Created    28 May 1999
 //
 //+----------------------------------------------------------------------------
 
 #include <stdio.h>
 #include <stdlib.h>
 
 #include "global.h"
 #include "debug.h"
 
 typedef int KEY;
 #define NOTFOUND -1
 extern int NumElements(KEY *x);  // to return the # of elements in an array
 
 
 //+----------------------------------------------------------------------------
 //
 // Function:  bsearch
 //
 // Synopsis:  Search for the target value in an array.  Return the
 //            index on success and NOTFOUND, or -1, on failure.
 //
 // Arguments: KEY kTarget - target value
 //            KEY *pkSearchspace - pointer to the search space
 //            
 // Returns:   DWORD
 //
 // History:   sgasch Created Header    28 May 1999
 //
 //+----------------------------------------------------------------------------
 DWORD bsearch(KEY kTarget, KEY *pkSearchspace) 
 {
 
 	BOOL fFound = NO;                        // have we found it yet?
 	DWORD dwFirst = 0;                       // search space starts at index zero
 	DWORD dwLast = NumElements(searchspace); // # of elements in search space
 	DWORD dwMidpoint;                        // current midpoint
 
 	//
 	// Check return value of NumElements and make precondition assertions
 	//
 	ASSERT(dwLast >= dwFirst);
 	ASSERT(pkSearchspace);
 
 	//
 	// iterative implementation -- could also be done recursively
 	//
 	while ((dwFirst <= dwLast) && (!fFound)) 
 	{
 
 		//
 		// calculate the dwMidpoint of the current [sub]range
 		//
 		dwMidpoint = (dwFirst + dwLast) / 2;
 
 		//
 		// compare the target with the value of dwMidpoint element
 		//
 		if (pkSearchspace[dwMidpoint] == kTarget) 
 		{
 			fFound = YES;
 		}
 		else 
 		{
 			//
 			// if the dwMidpoint is not the target adjust the range accordingly 
 			//
 			if (target < searchspace[dwMidpoint]) 
 			{
 				dwLast = dwMidpoint - 1;
 			}
 			else
 			{ 
 				dwFirst = dwMidpoint + 1;
 			}
 		}
 		
 		//
 		// Return value
 		//
 		if (fFound) 
 		{
 			return(dwMidpoint);
 		} 
 		else
 		{
 			return(NOTFOUND);
 		}
 	}    
 }
 
</PRE>
<BR><HR>
<BR></TT></DIV><HR><P>
</TD></TABLE></TD></TABLE>

<!--End of Navigation Panel-->
<ADDRESS>
<I>Scott Gasch</I>
<BR><I>1999-07-09</I>
</ADDRESS>
</BODY>
</HTML>
