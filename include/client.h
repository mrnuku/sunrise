// client.h -- primary header for client

//define	PARANOID			// speed sapping error checking

//=============================================================================

class frame_t {
public:
	bool			valid;			// cleared if delta parsing was invalid
	int				serverframe;
	timeType		servertime;		// server time the message is valid for( in msec )
	int				deltaframe;
	byte			areabits[ MAX_MAP_AREAS/8 ];		// portalarea visibility bits
	player_state_t	playerstate;
	int				num_entities;
	int				parse_entities;	// non-masked index into cl_parse_entities array

	void			Clear( );
};

class centity_t {
public:
	entity_state_t	baseline;		// delta from this if not from a previous frame
	entity_state_t	current;
	entity_state_t	prev;			// will always be valid, but might just be a copy of current

	int			serverframe;		// if not current, this ent isn't in the frame

	int			trailcount;			// for diminishing grenade trails
	Vec3		lerp_origin;		// for trails( variable hz )

	int			fly_stoptime;

	void		Clear( );
};

class clientinfo_t {
public:
	Str						name;
	Str						cinfo;
	TextureBase *			skin;
	TextureBase *			icon;
	Str						iconname;
	RenderModel	*			model;
	List< RenderModel * >	weaponmodel;

	void					Clear( );
};

#define	CMD_BACKUP			64	// allow a lot of command backups for very fast systems
#define	CMD_BACKUP_MASK		( CMD_BACKUP - 1 )

//
// the client_state_t structure is wiped completely at every
// server map change
//
class ClientStateData {
public:
	int			timeoutcount;

	int			timedemo_frames;
	timeType	timedemo_start;

	bool	refresh_prepped;	// false if on new level or new ref dll
	bool	sound_prepped;		// ambient sounds can start
	bool	force_refdef;		// vid has changed, so we can't use a paused refdef

	int			parse_entities;		// index( not anded off ) into cl_parse_entities[]

	usercmd_t	cmd;
	usercmd_t	cmds[ CMD_BACKUP ];	// each mesage will send several old cmds
	timeType	cmd_time[ CMD_BACKUP ];	// time sent, for calculating pings
	short		predicted_origins[ CMD_BACKUP ][ 3 ];	// for debug comparing against server

	float		predicted_step;				// for stair up smoothing
	timeType	predicted_step_time;

	Vec3		predicted_origin;	// generated by CL_PredictMovement
	Vec3		predicted_angles;
	Vec3		prediction_error;

	frame_t		frame;				// received from server
	int			surpressCount;		// number of messages rate supressed
	frame_t		frames[ UPDATE_BACKUP ];

	// the client maintains its own ea of view angles, which are
	// sent to the server each frame.  It is cleared to 0 upon entering each level.
	// the server sends a delta each frame which is added to the locally
	// tracked view angles to account for standing on rotating objects, // and teleport direction changes
	Vec3		viewangles;

	timeType	time;			// this is the time value that the client
								// is rendering at.  always <= cls.realtime
	float		lerpfrac;		// between oldframe and frame

	Scene		refdef;

	Vec3		v_forward, v_right, v_up;	// set when refdef.angles is set

	//
	// transient data from server
	//
	Str		layout;		// general 2D overlay
	int			inventory[ MAX_ITEMS ];

	//
	// non-gameserver infornamtion
	// FIXME: move this cinematic stuff into the cin_t structure
#if 0
	File		cinematic_file;
	int			cinematictime;		// cls.realtime for first cinematic frame
	int			cinematicframe;
	char		cinematicpalette[ 768 ];
	bool	cinematicpalette_active;
#endif

	//
	// server state information
	//
	bool	attractloop;		// running the attract loop, any key will menu
	int			servercount;	// server entification for prespawns
	Str		gamedir;
	int			playernum;

	Str		configstrings[ MAX_CONFIGSTRINGS ];

	//
	// locally derived information from server state
	//
	RenderModel	*		model_draw[ MAX_MODELS ];
	CModel *			model_clip[ MAX_MODELS ];

	//struct sfx_s	* sound_precache[ MAX_SOUNDS ];
	SoundBuffer *		sound_precache[ MAX_SOUNDS ];
	TextureBase *		image_precache[ MAX_IMAGES ];

	clientinfo_t	clientinfo[ MAX_CLIENTS ];
	clientinfo_t	baseclientinfo;

	void			Clear( );
};

/*
==================================================================

the client_static_t structure is persistant through an arbitrary number
of server connections

==================================================================
*/

typedef enum {
	ca_uninitialized,
	ca_disconnected, 	// not talking to a server
	ca_challenge,
	ca_connecting, 		// sending request packets to the server
	ca_connected, 		// netchan_t established, waiting for svc_serverdata
	ca_active			// game views should be displayed
} connstate_t;

typedef enum {
	dl_none,
	dl_model,
	dl_sound,
	dl_skin,
	dl_single
} dltype_t;		// download type

typedef enum {
	key_game,
	key_console,
	key_message,
	key_menu
} keydest_t;

class ClientStaticData {
public:

	connstate_t	state;
	keydest_t	key_dest;

	int				framecount;
	timeType		realtime;			// always increasing, no clamping, etc
	timeType		extratime;
	timeTypeReal	frametime;			// seconds since last frame

// screen rendering information
	timeType	disable_screen;		// showing loading plaque between levels
									// or changing rendering dlls
									// if time gets > 30 seconds ahead, break it
	int			disable_servercount;	// when we receive a frame and cl.servercount
									// > cls.disable_servercount, clear disable_screen

// connection information
	Str			servername;	// name of server from original connect
	timeType	connect_time;		// for connection retransmits

	int			quakePort;			// a 16 bit value that allows quake servers
									// to work around address translating routers
	NetworkPort		d_clientPort;
	MessageChannel	d_clientChannel;
	int			serverProtocol;		// in case we are doing some kind of version hack

	int			challenge;			// from the server to use for connecting

	FileBase *	download;			// file transfer from server
	Str			downloadtempname;
	Str			downloadname;
	int			downloadnumber;
	dltype_t	downloadtype;
	int			downloadpercent;

// demo recording info must be here, so it isn't cleared on level change
	bool	demorecording;
	bool	demowaiting;	// don't record until a non-delta message is received
	FileBase *	demofile;

	void		Clear( );
};

//=============================================================================

typedef struct {

	int			key;				// so entities can reuse same entry
	Vec3		color;
	Vec3		origin;
	float		radius;
	timeType	die;				// stop lighting after this time
	float		decay;				// drop this each second
	float		minlight;			// don't add when contributing less

} cdlight_t;


// the cl_parse_entities must be large enough to hold UPDATE_BACKUP frames of
// entities, so that when a delta compressed message arives from the server
// it can be un-deltad from the original 
#define	MAX_PARSE_ENTITIES	1024

//=============================================================================

//ROGUE
typedef struct cl_sustain {

	int			id;
	int			type;
	timeType	endtime;
	timeType	nextthink;
	int			thinkinterval;
	Vec3		org;
	Vec3		dir;
	int			color;
	int			count;
	int			magnitude;
	void		( *think )( struct cl_sustain * self );

} cl_sustain_t;

#define MAX_SUSTAINS		32


//=================================================

// ========
// PGM
typedef struct particle_s {

	struct particle_s	* next;

	timeType	time;

	Vec3		org;
	Vec3		vel;
	Vec3		accel;
	float		color;
	float		colorvel;
	float		alpha;
	float		alphavel;
} cparticle_t;


#define	PARTICLE_GRAVITY	40.0f
#define BLASTER_PARTICLE_COLOR		0xE0
// PMM
#define INSTANT_PARTICLE	-10000.0f
// PGM
// ========

class Client {

	// FIXME
	friend class	Video;
	friend class	View;
	friend class	Screen;
	friend class	Input;
	friend class	Command;
	friend class	Sound;
	friend class	Menu;
	friend class	Keyboard;
	friend class	Console;
	friend class	MovieExport;

private:

	static CVar		adr0;
	static CVar		adr1;
	static CVar		adr2;
	static CVar		adr3;
	static CVar		adr4;
	static CVar		adr5;
	static CVar		adr6;
	static CVar		adr7;
	static CVar		adr8;

	static CVar		cl_gun;
	static CVar		cl_footsteps;
	static CVar		cl_noskins;
	static CVar		cl_predict;
	static CVar		cl_maxfps;

	static CVar		cl_upspeed;
	static CVar		cl_forwardspeed;
	static CVar		cl_sidespeed;
	static CVar		cl_yawspeed;
	static CVar		cl_pitchspeed;
	static CVar		cl_anglespeedkey;

	static CVar		cl_run;

	static CVar		cl_shownet;
	static CVar		cl_showmiss;
	static CVar		cl_timeout;
	static CVar		cl_timedemo;

	//
	// userinfo
	//
	static CVar		info_password;
	static CVar		info_spectator;
	static CVar		name;
	static CVar		model;
	static CVar		weapon;
	static CVar		skin;
	static CVar		icon;
	static CVar		rate;
	static CVar		msg;
	static CVar		hand;
	static CVar		fov;

	static CVar		cl_vwep;
	static CVar		cl_nodelta;

	static const Str		env_suf[ ];
	static const Str		svc_strings[ ];

	static RenderModel *		cl_mod_smoke;
	static RenderModel *		cl_mod_flash;

	static ClientStaticData		cls;
	static ClientStateData		cl;

	static centity_t			cl_entities[ MAX_EDICTS ];

	static entity_state_t		cl_parse_entities[ MAX_PARSE_ENTITIES ];

	static MessageBufferT< MAX_MSGLEN >	cl_messageBuffer;
	static MessageBufferT< MAX_MSGLEN >	cl_messageBufferReliable;

public:

	static const MessageChannel &	CL_GetMessageChannel( ) { return cls.d_clientChannel; }

	static bool			CL_CheckOrDownloadFile( const Str & filename );

	static void			CL_AddNetgraph( );

	static void			CL_ParticleSteamEffect2( cl_sustain_t * self );

	static void			CL_TeleporterParticles( entity_state_t * ent );
	static void			CL_ParticleEffect( Vec3 & org, Vec3 & dir, int color, int count );
	static void			CL_ParticleEffect2( Vec3 & org, Vec3 & dir, int color, int count );

	// RAFAEL
	static void			CL_ParticleEffect3( Vec3 & org, Vec3 & dir, int color, int count );

	static void			CL_ClearEffects( );
	static void			CL_ClearTEnts( );
	static void			CL_BlasterTrail( Vec3 & start, Vec3 & end );
	static void			CL_QuadTrail( Vec3 & start, Vec3 & end );
	static void			CL_RailTrail( Vec3 & start, Vec3 & end );
	static void			CL_BubbleTrail( Vec3 & start, Vec3 & end );
	static void			CL_FlagTrail( Vec3 & start, Vec3 & end, float color );

	// RAFAEL
	static void			CL_IonripperTrail( Vec3 & start, Vec3 & end );

	// ========
	// PGM
	static void			CL_BlasterParticles2( Vec3 & org, Vec3 & dir, unsigned int color );
	static void			CL_BlasterTrail2( Vec3 & start, Vec3 & end );
	static void			CL_DebugTrail( Vec3 & start, Vec3 & end );
	static void			CL_SmokeTrail( Vec3 & start, Vec3 & end, int colorStart, int colorRun, int spacing );
	static void			CL_Flashlight( int ent, Vec3 & pos );
	static void			CL_ForceWall( Vec3 & start, Vec3 & end, int color );
	static void			CL_FlameEffects( centity_t * ent, Vec3 & origin );
	static void			CL_GenericParticleEffect( Vec3 & org, Vec3 & dir, int color, int count, int numcolors, int dirspread, float alphavel );
	static void			CL_BubbleTrail2( Vec3 & start, Vec3 & end, int dist );
	static void			CL_Heatbeam( Vec3 & start, Vec3 & end );
	static void			CL_ParticleSteamEffect( Vec3 & org, Vec3 & dir, int color, int count, int magnitude );
	static void			CL_TrackerTrail( Vec3 & start, Vec3 & end, int particleColor );
	static void			CL_Tracker_Explode( Vec3 & origin );
	static void			CL_TagTrail( Vec3 & start, Vec3 & end, float color );
	static void			CL_ColorFlash( Vec3 & pos, int ent, int intensity, float r, float g, float b );
	static void			CL_Tracker_Shell( Vec3 & origin );
	static void			CL_MonsterPlasma_Shell( Vec3 & origin );
	static void			CL_ColorExplosionParticles( Vec3 & org, int color, int run );
	static void			CL_ParticleSmokeEffect( Vec3 & org, Vec3 & dir, int color, int count, int magnitude );
	static void			CL_Widowbeamout( cl_sustain_t * self );
	static void			CL_Nukeblast( cl_sustain_t * self );
	static void			CL_WidowSplash( Vec3 & org );
	// PGM
	// ========

	/// Returns the entity number and the header bits
	static int			CL_ParseEntityBits( MessageBuffer & msg_buffer, unsigned * bits );
	/// Can go from either a baseline or a previous packet_entity
	static void			CL_ParseDelta( MessageBuffer & msg_buffer, entity_state_t * from, entity_state_t * to, int number, int bits );
	static void			CL_ParseFrame( MessageBuffer & msg_buffer );

	static void			CL_ParseTEnt( MessageBuffer & msg_buffer );
	static void			CL_ParseConfigString( MessageBuffer & msg_buffer );
	static void			CL_ParseMuzzleFlash( MessageBuffer & msg_buffer );
	static void			CL_ParseMuzzleFlash2( MessageBuffer & msg_buffer );
	static void			SmokeAndFlash( Vec3 & origin );

	static void			CL_SetLightstyle( int i );

	static void			CL_RunParticles( );
	static void			CL_RunDLights( );
	static void			CL_RunLightStyles( );

	/// Emits all entities, particles, and lights to the refresh
	static void			CL_AddEntities( );
	static void			CL_AddDLights( );
	static void			CL_AddTEnts( );
	static void			CL_AddLightStyles( );

	//=================================================

	static void			CL_PrepRefresh( );
	static void			CL_RegisterSounds( );
	static void			CL_Quit_f( );
	static void			IN_Accumulate( );
	static void			CL_ParseLayout( );

	// cl_ents.cpp
	/// Parses deltas from the given base and adds the resulting entity to the current frame
	static void		CL_DeltaEntity( MessageBuffer & msg_buffer, frame_t * frame, int newnum, entity_state_t * old, int bits );
	/// An svc_packetentities has just been parsed, deal with the rest of the data stream.
	static void		CL_ParsePacketEntities( MessageBuffer & msg_buffer, frame_t * oldframe, frame_t * newframe );
	static void		CL_ParsePlayerstate( MessageBuffer & msg_buffer, frame_t * oldframe, frame_t * newframe );
	static void		CL_FireEntityEvents( frame_t * frame );
	static void		CL_AddPacketEntities( frame_t * frame );
	static void		CL_AddViewWeapon( player_state_t * ps, player_state_t * ops );
	/// Sets cl.refdef view values
	static void		CL_CalcViewValues( );

	// cl_main.cpp
	static void			CL_Init( );

	static void			CL_Disconnect( );
	static void			CL_Disconnect_f( );
	static void			CL_GetChallengePacket( );
	static void			CL_PingServers_f( );
	static void			CL_Snd_Restart_f( );
	static void			CL_RequestNextDownload( );

	// cl_input.cpp
	static void			CL_InitInput( );
	static void			CL_BuildCmd( MessageBuffer & msg_buffer );
	static void			CL_SendMove( usercmd_t * cmd );
	// Moves the local angle positions
	static void			CL_AdjustAngles( );
	static void			CL_ClampPitch( );
	static void			CL_CreateCmd( usercmd_t & cmd );
	static void			CL_FinishMove( usercmd_t * cmd );

	static void			CL_ClearState( );

	static void			CL_ReadPackets( );

	static int			CL_ReadFromServer( );
	static void			CL_WriteToServer( usercmd_t * cmd );
	// Send the intended movement message to the server
	static void			CL_BaseMove( usercmd_t * cmd );

	static void			IN_CenterView( );

	// Returns the fraction of the frame that the key was down
	static float		CL_KeyState( kbutton_t * key );

	static void			CL_WriteDemoMessage( MessageBuffer & msg_buffer );
	static void			CL_Stop_f( );
	static void			CL_Record_f( );


	// cl_parse.cpp
	static void			CL_ParseServerMessage( MessageBuffer & msg_buffer );
	static void			CL_LoadClientinfo( clientinfo_t * ci, const Str & s );
	static void			SHOWNET( MessageBuffer & msg_buffer, const Str & str );
	static void			CL_ParseClientinfo( int player );
	static void			CL_Download_f( );
	static void			CL_ParseDownload( MessageBuffer & msg_buffer );
	static void			CL_ParseServerData( MessageBuffer & msg_buffer );
	static void			CL_ParseBaseline( MessageBuffer & msg_buffer );
	static void			CL_ParseStartSoundPacket( MessageBuffer & msg_buffer );

	// cl_tent.cpp
	static void			CL_RegisterTEntSounds( );
	static void			CL_RegisterTEntModels( );
	static void			CL_SmokeAndFlash( Vec3 & origin );
	static struct			explosion_s * 	CL_AllocExplosion( );
	static void			CL_ParseParticles( MessageBuffer & msg_buffer );
	static int		CL_ParseBeam( MessageBuffer & msg_buffer, RenderModel * model );
	static int		CL_ParseBeam2( MessageBuffer & msg_buffer, RenderModel * model );
	// - adds to the cl_playerbeam array instead of the cl_beams array
	static int		CL_ParsePlayerBeam( MessageBuffer & msg_buffer, RenderModel * model );
	static int		CL_ParseLightning( MessageBuffer & msg_buffer, RenderModel * model );
	static void		CL_ParseLaser( MessageBuffer & msg_buffer, int colors );
	static void		CL_ParseSteam( MessageBuffer & msg_buffer );
	static void		CL_AddBeams( );
	// draw player locked beams
	static void		CL_AddPlayerBeams( );
	static void		CL_AddExplosions( );
	static void		CL_AddLasers( );
	static void		CL_ProcessSustain( );
	static void		CL_ParseWidow( MessageBuffer & msg_buffer );
	static void		CL_ParseNuke( MessageBuffer & msg_buffer );

	// cl_pred.cpp
	static void			CL_InitPrediction( );
	static void			CL_PredictMove( );
	static void			CL_CheckPredictionError( );
	static void		CL_ClipMoveToEntities( Vec3 & start, Vec3 & mins, Vec3 & maxs, Vec3 & end, CTrace & tr );
	static CTrace		CL_PMTrace( Vec3 & start, Vec3 & mins, Vec3 & maxs, Vec3 & end );
	static int		CL_PMpointcontents( Vec3 & point );

	// cl_fx.cpp
	static cdlight_t			* CL_AllocDlight( int key );
	static void			CL_BigTeleportParticles( Vec3 & org );
	static void			CL_RocketTrail( Vec3 & start, Vec3 & end, centity_t * old );
	static void			CL_DiminishingTrail( Vec3 & start, Vec3 & end, centity_t * old, int flags );
	static void			CL_FlyEffect( centity_t * ent, Vec3 & origin );
	//static void			CL_BfgParticles( entity_t * ent );
	static void			CL_AddParticles( );
	static void			CL_EntityEvent( entity_state_t * ent );
	// RAFAEL
	//static void			CL_TrapParticles( entity_t * ent );

	static void		CL_ClearLightStyles( );
	static void		CL_ClearDlights( );
	static void		CL_NewDlight( int key, float x, float y, float z, float radius, timeType time );
	static void		CL_LogoutEffect( Vec3 & org, int type );
	static void		CL_ClearParticles( );
	static void		CL_ItemRespawnParticles( Vec3 & org );
	static void		CL_ExplosionParticles( Vec3 & org );
	static void		CL_BlasterParticles( Vec3 & org, Vec3 & dir );
	static void		CL_FlyParticles( Vec3 & origin, int count );
	static void		CL_BFGExplosionParticles( Vec3 & org );
	static void		CL_TeleportParticles( Vec3 & org );

	//
	// cl_inv.c
	//
	static void			CL_ParseInventory( MessageBuffer & msg_buffer );
	static void			CL_KeyInventory( int key );
	static void			CL_DrawInventory( );

	//
	// cl_pred.c
	// Sets cl.predicted_origin and cl.predicted_angles
	static void			CL_PredictMovement( );

	// the sound code makes callbacks to the client for entitiy position
	// information, so entities can be dynamically re-spatialized
	static Vec3			CL_GetEntitySoundOrigin( int ent );

	// cl_main.cpp
	static void		InitPort( );
	static void		CL_ForwardToServer_f( );
	static void		CL_Pause_f( );
	static void		CL_Drop( );
	static void		CL_SendConnectPacket( netadr_t & to );
	static void		CL_CheckForResend( );
	static void		CL_Connect_f( );
	static void		CL_Packet_f( );
	static void		CL_Changing_f( );
	static void		CL_Reconnect_f( );
	static void		CL_ParseStatusMessage( MessageBuffer & msg_buffer );
	static void		CL_Skins_f( );
	static void		CL_ConnectionlessPacket( MessageBuffer & msg_buffer, netadr_t & msg_from );
	static void		CL_DumpPackets( );
	static void		CL_Userinfo_f( );
	static void		CL_Precache_f( );
	static void		CL_InitLocal( );
	static void		CL_WriteConfiguration( );
	static void		CL_SendCommand( );
	static void		CL_Frame( timeType msec );
	static void		CL_Shutdown( );

	// adds the current command line as a clc_stringcmd to the client message.
	// things like godmode, noclip, etc, are commands directed to the server, // so when they are typed in at the console, they will need to be forwarded.
	static void		Cmd_ForwardToServer( );
};

class View {

	friend class	Client;

private:

	static CVar		crosshair;
	static CVar		cl_testblend;
	static CVar		cl_testparticles;
	static CVar		cl_testentities;
	static CVar		cl_testlights;
	static CVar		cl_stats;
	static CVar		cl_add_blend;
	static CVar		cl_add_lights;
	static CVar		cl_add_particles;
	static CVar		cl_add_entities;

	//=============
	//
	// development tools for weapons
	//
	static int					gun_frame;
	static RenderModel *		gun_model;

	//=============

	static List< SceneEntity >		r_entities;
	static List< SceneLight >		r_dlights;

	static List< Str >				cl_weaponmodels;

public:

	// cl_view.cpp
	static void			V_Init( );
	static void			V_RenderView( );
	static void			V_AddEntity( const SceneEntity & ent );
	static void			V_AddParticle( Vec3 & org, int color, float alpha );
	static void			V_AddLight( Vec3 & org, float intensity, float r, float g, float b );
	static void			V_AddLightStyle( int style, float r, float g, float b );
	static void			V_ClearScene( );
	static void			V_TestParticles( );
	static void			V_TestEntities( );
	static void			V_TestLights( );
	static void			V_Gun_Next_f( );
	static void			V_Gun_Prev_f( );
	static void			V_Gun_Model_f( );
	static void			V_Viewpos_f( );
	static float		CalcFov( float fov_x, float width, float height );
	static void			SCR_DrawCrosshair( );
};
